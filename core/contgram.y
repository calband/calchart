%{
/* contgram.y
 * YACC grammar for continuity
 *
 * Modification history:
 * 10-18-95   Garrick Meeker              Created
 *
 */

/*
   Copyright (C) 1995-2011  Garrick Brian Meeker, Richard Michael Powell

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "CalChartContinuityToken.h"
#include "parse.h"
#include "CalChartAnimation.h"

#include <vector>

#if __cplusplus > 199711L
#define register      // Deprecated in C++11.
#endif  // #if __cplusplus > 199711L

//#define YYDEBUG 1

int yyerror(const char *s);
extern int yylex();
extern void initscanner();

std::vector<std::unique_ptr<CalChart::Cont::Procedure>> ParsedContinuity;

%}

%{
#ifdef _MSC_VER
#pragma warning (disable : 4065) //Disable the "switch statement contains 'default' but no 'case' labels" warning that is flagged by the code generated by Bison
#endif // _MSC_VER
%}

%{
	/* Reserved word definitions */
%}
%token rwP rwNP rwR rwREM rwSP rwDOF rwDOH
%token pBLAM pCOUNTERMARCH pDMCM pDMHS pEVEN pEWNS pFOUNTAIN pFM pFMTO
%token pGRID pHSDM pHSCM pMAGIC pMARCH pMT pMTRM pNSEW pROTATE
%token fDIR fDIRFROM fDIST fDISTFROM fEITHER fOPP fSTEP
%token UNKNOWN_TOKEN

%{
	/* Constants and variables */
%}
%token <f> FLOATCONST
%token <v> VARIABLE
%token <d> DEFINECONST

%{
	/* Operator definitions */
%}
%token '+' '-' '*' '/' '(' ')' '='

%{
	/* Semantic stack */
%}
%union {
	char v;
	float f;
	CalChart::Cont::DefinedValue d;
	CalChart::Cont::Procedure *proc;
	CalChart::Cont::Point *pnt;
	CalChart::Cont::Value *value;
	CalChart::Cont::ValueVar *var;
}

%type <list> proc_list
%type <proc> procedure
%type <pnt> point
%type <value> value
%type <value> function
%type <var> varvalue

%right UNARY    /* a psuedo terminal used only for unary - precedence */
%left '+' '-' '*' '/'

%%

proc_list
	: // Empty
		{}
	| proc_list procedure
		{ ParsedContinuity.emplace_back($2); }
	;

procedure
	: varvalue '=' value
		{ $$ = new CalChart::Cont::ProcSet($1, $3); }
	| pBLAM
		{ $$ = new CalChart::Cont::ProcBlam(); }
	| pCOUNTERMARCH point point value value value value
		{ $$ = new CalChart::Cont::ProcCM($2, $3, $4, $5, $6, $7); }
	| pDMCM point point value
		{ $$ = new CalChart::Cont::ProcDMCM($2, $3, $4); }
	| pDMHS point
		{ $$ = new CalChart::Cont::ProcDMHS($2); }
	| pEVEN value point
		{ $$ = new CalChart::Cont::ProcEven($2, $3); }
	| pEWNS point
		{ $$ = new CalChart::Cont::ProcEWNS($2); }
	| pFOUNTAIN value value point
		{ $$ = new CalChart::Cont::ProcFountain($2, $3, NULL, NULL, $4); }
	| pFOUNTAIN value value value value point
		{ $$ = new CalChart::Cont::ProcFountain($2, $3, $4, $5, $6); }
	| pFM value value
		{ $$ = new CalChart::Cont::ProcFM($2, $3); }
	| pFMTO point
		{ $$ = new CalChart::Cont::ProcFMTO($2); }
	| pGRID value
		{ $$ = new CalChart::Cont::ProcGrid($2); }
	| pHSCM point point value
		{ $$ = new CalChart::Cont::ProcHSCM($2, $3, $4); }
	| pHSDM point
		{ $$ = new CalChart::Cont::ProcHSDM($2); }
	| pMAGIC point
		{ $$ = new CalChart::Cont::ProcMagic($2); }
	| pMARCH value value value
		{ $$ = new CalChart::Cont::ProcMarch($2, $3, $4, NULL); }
	| pMARCH value value value value
		{ $$ = new CalChart::Cont::ProcMarch($2, $3, $4, $5); }
	| pMT value value
		{ $$ = new CalChart::Cont::ProcMT($2, $3); }
	| pMTRM value
		{ $$ = new CalChart::Cont::ProcMTRM($2); }
	| pNSEW point
		{ $$ = new CalChart::Cont::ProcNSEW($2); }
	| pROTATE value value point
		{ $$ = new CalChart::Cont::ProcRotate($2, $3, $4); }
	;

point
	: rwP
		{ $$ = new CalChart::Cont::Point(); }
	| rwSP
		{ $$ = new CalChart::Cont::StartPoint(); }
	| rwNP
		{ $$ = new CalChart::Cont::NextPoint(); }
	| rwR FLOATCONST
		{ $$ = new CalChart::Cont::RefPoint((unsigned)$2 - 0); }
	;

value
	: FLOATCONST
		{ $$ = new CalChart::Cont::ValueFloat($1); }
	| DEFINECONST
		{ $$ = new CalChart::Cont::ValueDefined($1); }
	| value '+' value
		{ $$ = new CalChart::Cont::ValueAdd($1, $3); }
	| value '-' value
		{ $$ = new CalChart::Cont::ValueSub($1, $3); }
	| value '*' value
		{ $$ = new CalChart::Cont::ValueMult($1, $3); }
	| value '/' value
		{ $$ = new CalChart::Cont::ValueDiv($1, $3); }
	| '-' value %prec UNARY
		{ $$ = new CalChart::Cont::ValueNeg($2); }
	| '(' value ')'
		{ $$ = $2; }
	| rwREM
		{ $$ = new CalChart::Cont::ValueREM(); }
	| rwDOF
		{ $$ = new CalChart::Cont::ValueVar(CalChart::Cont::Variable::DOF); }
	| rwDOH
		{ $$ = new CalChart::Cont::ValueVar(CalChart::Cont::Variable::DOH); }
	| varvalue
		{ $$ = $1; }
	| function
		{ $$ = $1; }
	;

function
	: fDIR '(' point ')'
		{ $$ = new CalChart::Cont::FuncDir($3); }
	| fDIRFROM '(' point point ')'
		{ $$ = new CalChart::Cont::FuncDirFrom($3, $4); }
	| fDIST '(' point ')'
		{ $$ = new CalChart::Cont::FuncDist($3); }
	| fDISTFROM '(' point point ')'
		{ $$ = new CalChart::Cont::FuncDistFrom($3, $4); }
	| fEITHER '(' value value point ')'
		{ $$ = new CalChart::Cont::FuncEither($3, $4, $5); }
	| fOPP '(' value ')'
		{ $$ = new CalChart::Cont::FuncOpp($3); }
	| fSTEP '(' value value point ')'
		{ $$ = new CalChart::Cont::FuncStep($3, $4, $5); }
	;

varvalue
	: VARIABLE
		{ unsigned i;
		  switch ($1) {
		  case 'A':
		  case 'a':
		    i = 0;
		    break;
		  case 'B':
		  case 'b':
		    i = 1;
		    break;
		  case 'C':
		  case 'c':
		    i = 2;
		    break;
		  case 'D':
		  case 'd':
		    i = 3;
		    break;
		  case 'X':
		  case 'x':
		    i = 4;
		    break;
		  case 'Y':
		  case 'y':
		    i = 5;
		    break;
		  case 'Z':
		  case 'z':
		  default:
		    i = 6;
		    break;
		  }
		  $$ = new CalChart::Cont::ValueVar(static_cast<CalChart::Cont::Variable>(i));
		}
	;

%%


//Stop supressing warnings at the end of Bison's generated code
#ifdef _MSC_VER
#pragma warning (default : 4065)
#endif // _MSC_VER


int parsecontinuity()
{
  ParsedContinuity.clear();
  initscanner();
//  yydebug = 1;
  return yyparse();
}

int yyerror(const char *)
{
  // handled outside
  return 0;
}
