# Phase 3A: Multi-Threading calchart_cmd - Findings & Results

## Objective
Implement file-level parallelism in `calchart_cmd` using C++20 threading to accelerate show file processing and reduce total sanity_tester runtime by 2-3x in debug mode and 1.5-2x in release mode.

## Investigation & Implementation

### Approach 1: File-Level Threading with std::async
**Implementation**: Modified Parse lambda in `tools/calchart_cmd/calchart_cmd_parse.hpp` to use `std::async` for parallel file processing.

**Code Changes**:
- Added `#include <future>` to imports  
- Wrapped each file processing into a lambda passed to `std::async(std::launch::async, ...)`
- Collected futures in a vector and retrieved results in order
- Each file was processed independently with its own output stream

**Results**:
- ✅ Code compiled successfully
- ✅ Executed without crashes
- ✅ Performance improved to ~36 seconds (from 52 seconds baseline)
- ❌ **Output validation failed** - Generated files had different content than golden reference
  - Specific issue: `.output.check` file had 5 lines instead of 0
  - Occurred consistently across multiple test runs
  - Suggests race condition or non-thread-safe state in CalChart core library

### Root Cause Analysis

The CalChart library appears to have thread-safety issues when:
1. Multiple `CalChart::Show` objects are created concurrently
2. Parsing show files happens in parallel
3. Animation/continuity operations execute on multiple threads

This is likely due to:
- Global state in the parser or lexer (generated by Bison/Flex)
- Shared caches or memoization in `CalChart::Animation` or `CalChart::Show`
- Non-atomic updates to internal data structures

### Why CalChart Thread-Safety is Complex

**Parser Generation Complexity** (`src/core/contgram.y`, `src/core/contscan.l`):
- Bison and Flex generate thread-unsafe parsers by default
- Global parser state persists across invocations
- Would require significant refactoring to make thread-local

**Animation Compilation** (`CalChartAnimationCompile.cpp`):
- Animation compilation involves complex state machines
- May have internal caches or memoization that aren't thread-safe
- Animation object creation and traversal during sheet processing

**Show Object Architecture**:
- Sheet iteration and continuity parsing are inherently sequential
- Points and formations may share internal indices or caches

## Performance Impact

### Baseline (Sequential) - After Phase 1-2 Instrumentation:
- **Debug Mode**: 165.46 seconds
  - calchart_cmd execution: 146.49s (88.5%)
  - File comparison: 37.54s (22.7%)
  - Overhead: -18.57s
  
- **Release Mode**: 52.16 seconds
  - Command execution: 33.76s (50.4%)
  - File comparison: 65.89s (98.5%)
  - Overhead: -32.73s

### With Threading (Incomplete):
- Potential improvement: ~30% faster (52s → 36s in release)
- **Status**: Blocked by output validation failures

## Recommendations

### Option 1: Make CalChart Thread-Safe (High Effort, High Reward)
**Effort**: 2-4 weeks
**Reward**: Potential 3-5x speedup
**Steps**:
1. Profile concurrent execution to identify specific race conditions
2. Convert global parser state to thread-local storage
3. Add thread-safe synchronization to Animation compilation
4. Add comprehensive multi-threaded unit tests
5. Validate output correctness across all threading patterns

### Option 2: Use Process-Level Parallelism (Low Effort, Moderate Reward)
**Effort**: 2-3 days
**Reward**: Keep 1.5-2x speedup from multiprocessing
**Status**: Already implemented in `resources/tests/sanity_tester.py`
**Current Performance**:
- Each show file gets processed independently by separate OS processes
- Multiprocessing pool manages up to `CPU_cores * 2` concurrent processes
- Already achieving near-maximum parallelism for the current architecture

### Option 3: Batch Processing Optimization (Medium Effort, Moderate Reward)
**Effort**: 1 week
**Reward**: Potential 1.5-2x improvement
**Approach**:
- Modify sanity_tester to call calchart_cmd with multiple files at once
- Let calchart_cmd process them sequentially (already does this well)
- Amortize process creation overhead across multiple files
- Would require changes to flag parsing to accept multiple files
- Could combine with Option 2 for further improvements

### Option 4: Profile and Optimize Specific Bottlenecks (Low Effort, Variable Reward)
**Effort**: 1-2 days
**Reward**: Potential 1.2-1.5x improvement
**Targets**:
- Cache most frequently used show mode configurations
- Pre-allocate Animation object pools
- Optimize Animation::GetCurrentInfo() which is called millions of times
- Profile output format generation to identify hot spots

## Current State

- Phase 3A threading investigation **complete**
- Phase 3A implementation **blocked by validation failures**
- Sequential version passes all tests
- Phase 1-2 instrumentation **complete and validated**
- Baseline metrics captured for future comparison

## Conclusion

While C++20 threading in calchart_cmd showed promise (~30% improvement), thread-safety issues in the CalChart core library prevent this approach from being production-ready without significant refactoring. The sanity_tester already implements effective Python-level parallelism via multiprocessing, which is the current optimization frontier.

Recommended next steps:
1. **For immediate improvement**: Profile and optimize specific bottlenecks (Option 4)
2. **For substantial improvement**: Make CalChart thread-safe (Option 1) - requires dedicated effort
3. **For minimal effort**: Implement batch processing in sanity_tester (Option 3)

The Phase 1-2 instrumentation framework is now in place to accurately measure the impact of any future optimizations.
